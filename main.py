import os
import requests

from VKrequest import VKRequest
from yaDiskRequest import YaDiskRequest

#
# #####################################################################
# #####################################################################
#
# # Формат данных по фото:
# # {'id', 'album_id', 'owner_id', 'user_id', 'text', 'date', 'sizes':[{}], 'width', 'height', 'url', 'likes', 'reposts'}
# #   Массив 'sizes' содержит записи следующего формата:
# #       {'src', 'width', 'height', 'type'}
# #           Поле 'type' (строка, точнее 1 символ):
# #               's' — Пропорциональная копия изображения с максимальной стороной 75px;
# #               'm' — Пропорциональная копия изображения с максимальной стороной 130px;
# #               'x' — Пропорциональная копия изображения с максимальной стороной 604px;
# #               'o' — Если соотношение "ширина/высота" исходного изображения меньше или равно 3:2, то пропорциональная копия с максимальной стороной 130px. Если соотношение "ширина/высота" больше 3:2, то копия обрезанного слева изображения с максимальной стороной 130px и соотношением сторон 3:2.
# #               'p' — Если соотношение "ширина/высота" исходного изображения меньше или равно 3:2, то пропорциональная копия с максимальной стороной 200px. Если соотношение "ширина/высота" больше 3:2, то копия обрезанного слева и справа изображения с максимальной стороной 200px и соотношением сторон 3:2.
# #               'q' — Если соотношение "ширина/высота" исходного изображения меньше или равно 3:2, то пропорциональная копия с максимальной стороной 320px. Если соотношение "ширина/высота" больше 3:2, то копия обрезанного слева и справа изображения с максимальной стороной 320px и соотношением сторон 3:2.
# #               'r' — Если соотношение "ширина/высота" исходного изображения меньше или равно 3:2, то пропорциональная копия с максимальной стороной 510px. Если соотношение "ширина/высота" больше 3:2, то копия обрезанного слева и справа изображения с максимальной стороной 510px и соотношением сторон 3:2
# #               'y' — Пропорциональная копия изображения с максимальной стороной 807px;
# #               'z' — Пропорциональная копия изображения с максимальным размером 1080x1024;
# #               'w' — Пропорциональная копия изображения с максимальным размером 2560x2048px.
# # Example:
# #   sizes: [{
# #           src: 'https://pp.vk.me/c633825/v633825034/7369/wbsAsrooqfA.jpg',
# #           width: 130,
# #           height: 87,
# #           type: 'm'
# #          }
#
# #####################################################################
#
# # Функция определения наибольшего размера фото
# # PARAMS
# #   PHOTO - словарь с данными о фото (формат ВК)
# # RETURN
# #   словарь со следущими значениями:
# #   { 'size': буква-идентификатор размера фото
# #     'src': url для скачивания фото выбранного размерешния
# #   }
# def get_max_photo_size(photo):
#     # TODO
#     # В цикле по списку 'sizes' найти элемент, у которого наибольшее разрешение (width*height)
#     # и вернуть следующий словарь:
#     #   { 'size': 'l' (буква из поля 'type')
#     #     'src': url (поле 'src')
#     #   }
#     ...
#
#
#
# #####################################################################
#
# # Функция определения расширения файла по его URL
# # PARAMS
# #   URL - URL для скачивания файла
# # RETURN
# #   расширение файла (строка)
# def get_photo_extension(url):
#     # TODO
#     # Написать код, который разбивает строку url на части по ключевому символу точка ('.')
#     # и возвращает последнюю часть (это и есть расширение файла)
#     ...
#
#
#
# #####################################################################
#
# # Функция сохранения фото во временной папке
# # PARAMS
# #   PHOTO - словарь с данными о фото (формат ВК)
# #   TMP_FOLDER - папка, в которой сохранять файл
# # RETURN
# #   имя сохраненного файла (без пути)
# def save_photo(photo, tmp_folder):
#     photo_size = get_max_photo_size(photo)
#     # имя файла "лайки_дата.расширение"
#     filename = f'{photo.likes}_{photo.date}.{get_photo_extension(photo_size.src)}'
#
#     # TODO
#     # Написать код, который берет данные по URL из photo_size['src']
#     # и сохраняет в виде файла с именем filename в папке tmp_folder
#
#     ...
#
#
#     return filename
#
# #####################################################################
#
# # Функция сохранения всех фото во временной папке
# # PARAMS
# #   DATA - список с полученными фото (формат ВК)
# # RETURN
# #   итоговый список в формате:
# #   [ {
# #       'file_name': имя файла
# #       'size': буква-идентификатор размера фото
# #       'src': url для скачивания фото выбранного размерешния
# #   },
# #   {...},
# #   ...
# # ]
# def parse_data_to_files(data, tmp_folder = 'temp'):
#     # TODO
#     # в цикле по списку DATA сделать следующее:
#     #   1. Найти наибольший размер фото (по массиву 'sizes')
#     #   2. Сохранить файл из соответствующей ссылке (поле 'src' в массиве 'sizes') в папке tmp_folder.
#     #      Имя файла задать следующее: {число_лайков}_{дата_загрузки}. Например '14_67890876.jpg'
#     #   3. Добавить в итоговый список (result) следующую запись:
#     #      { 'file_name': имя_сохраненного_файла,
#     #        'size': 'l' (буква в поле 'type' выбранного размера фото в массиве 'sizes')
#     #        'src': url (поле 'src' выбранного размера фото в массиве 'sizes')
#     #      }
#     # Функция возвращает итоговый список (result)
#     ...
#
#
# # Функция удаления всех файлов из папки и самой папки
# # PARAMS
# #   FOLDER - папка (по умолчанию, 'temp')
# # RETURN
# #   TRUE или FALSE (если ошибка удаления)
# def delete_folder(folder = 'temp'):
#     # TODO
#     # 1. Удалить все файлы из папки
#     # 2. Удалить саму папку
#     # 3. Если все успешно - вернуть True, иначе False
#     ...
#
#
#
# #####################################################################
#
# # Функция получения числа файлов в указанной папке
# # PARAMS
# #   PATH - папка, в которой лежат файлы
# # RETURN
# #   число файлов в папке
# def get_files_count(path):
#     # формирование полного пути до файлов
#     root_path = os.getcwd()
#     full_path = os.path.join(root_path, path)
#     # Список файлов по пути full_path
#     files = os.listdir(full_path)
#     return len(files)
#
# #####################################################################
# #####################################################################

if __name__ == '__main__':
    # необходимые данные для авторизации ВК
    vk_user_id = ''
    vk_token = ''
    # необходимые данные для авторизации YaDisk
    ya_token = ''
    # временная папка для хранения фото
    temp_folder = 'temp'
    # папка на YaDisk, куда будут загружаться фото
    ya_folder = 'vdvyxa'

    # создание объектов по работе с VK и YaDisk
    vk_request = VKRequest(vk_user_id, vk_token, token_file="vk_token.txt")
    ya_request = YaDiskRequest(ya_token, token_file="ya_token.txt")
    vk_user_id = vk_request.user_id
    # получение фото себя из ВК
    photos = vk_request.get_user_photos(vk_user_id)
    print(photos)
    # обработка данных и сохранение фото во временной папке
    # по умолчанию, берется 5 фото
    # datainfo = parse_data_to_files(photos, temp_folder)
    # # подсчет количества полученных файлов с фото
    # files_count = get_files_count(temp_folder)
    # # загрузка файлов с фото на YaDisk
    # uploaded_count = ya_request.upload_files(temp_folder, ya_folder)
    #
    # # Вывод информации на экран
    # print(f'Totat {len(photos)} photos, {files_count} files saved and {uploaded_count} uploaded.')
    #
    # # Удаление временной папки - очистка следов
    # delete_folder(temp_folder)

